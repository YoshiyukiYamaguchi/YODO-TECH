■コンソール実行とmainメソッドについて
▼ コンパイル
・ソースコードをテキストファイルで記述後(テキストファイルの拡張子は「.java」で作成)、コンパイルを行う。コンパイルのコマンドは「javac [ファイル名.java]」
・コンパイルが成功すると、プログラムが実行可能なクラスファイルが生成される。実行のコマンドは、「java [クラス名] [引数]」[引数]は半角スペースを空け複数記述可能(又は省略可能)。実行時に配列に変換され、mainメソッドの[args]に代入される。

▼ mainメソッド
▼public static void main(String[] args){}
・mainメソッドはJavaアプリケーションのエントリーポイント(入口)となるメソッド。VVMがアプリケーションが実行された際に、自動で呼び出すメソッド。
・mainメソッドは、アクセスレベル:「public」　静的:「static」　戻り値:「void」　メソッド名:「main」　引数:String型の配列 ←これらの条件を満たさない場合、「NoSuchMethodError：main」となる。
・mainメソッドの引数であるString型配列の変数名は任意である。
・引数のString配列はnullではなく、コマンドラインから引数を渡されなければ参照を持った要素数0の配列(JVMが実行時に生成する)。変数からメソッドを起動しても「NullPointerException」は発生しないので注意。

■パッケージとインポートについて
▼パッケージ
・パッケージとは、クラスやインターフェースをグループ化して分割する仕組み。
パッケージに分割すると、クラスやインターフェースの「名前衝突」を防ぐことができる。
Javaでプログラミングをすると多数のクラスを作成する場面が多々ある。
Javaのクラスには重複したクラス名をつける事はできない。
しかし、グループ化して分けてさえいれば、同じクラス名をつけていても問題は発生しなくなる。
同じ機能や関連するクラスをグループ化して分けていることで、クラスも検索しやすくなり、
修正や改良する際に探す手間も省く事ができる。
・クラスやインターフェースは「フォルダ」でグループ分けする。
▼例
フォルダの改装が第1階層から第3階層まであり、第3階層でクラスを定義する。
この場合、パッケージ名は
第1階層フォルダ名.第2階層フォルダ名.第3階層フォルダ名
といったように「.」(ピリオド)を使って第1階層から順にフォルダ名を連結してパッケージ名をつける。
また、フォルダ名は小文字が推奨されている。
・「パッケージ宣言はクラスの先頭で行う必要がある。」
Javaには、パッケージ名の衝突を防ぐ仕組みはなく、インターネットドメイン名(DNSドメイン名)
を利用することを推奨している。
【パッケージ宣言の実装例】
//↓「package」が予約語となっており、後ろにクラスファイルまでのパスを「.」(ピリオド)で繋げて記述している。
package rootdir.somedir.some-anotherdir //パッケージ宣言。クラスの先頭で記述
import somewhere.someclass
class Sample{}

▼インポート
・インポート文は、クラスやインターフェースに定義されたメンバ(メソッドとフィールド)を参照するために利用する。
・インポートには2種類ある。
1,単一型インポート
個別に型名を指定したインポート。
import java.util.List
2,オンデマンドインポート
アスタリスク(*)を利用したインポート。
import java.util.*

※オンデマンドインポートは単一型インポートと比較し、
「*」以降のフィールドやメソッドを一括でインポート出来るため、便利な反面、
単一型インポートで明示的にどのフィールドやメソッドを参照しているのかを明記したほうが可読性が上がるため、出来る限り単一型インポートを使用するようにする。

・インポートはクラスのアクセスレベルがデフォルト(何も修飾子がついていない)場合、同一パッケージのクラスのみインポートが出来る。

■演算について
▼オペランド
・オペランドとは式を構成する際に用いられる値(又は変数)の事。(演算子以外の部分)
※オペランド
↓   ↓
x + 10
「+」の部分が演算子で、式に用いられた左右の値をオペランドと呼ぶ。

▼代入演算子
・代入演算子は左オペランドに右オペランドの値を代入する際に使用する演算子。
演算子    使用例      意味
=         a = 10;     変数aに10を代入する。
+=        a += 10;    「a = a + 10」と同じ。変数aの値に10を足してから、変数aに結果を代入する。
-=        a -= 10;    「a = a - 10」と同じ。変数aの値から10引いてから、変数aに結果を代入する。
*=        a *= 10;    「a = a * 10」と同じ。変数aの値に10を掛けてから、変数aに結果を代入する。
/=        a /= 10;    「a = a / 10」と同じ。変数aの値に10を割ってから、変数aに結果を代入する。

・代入演算子は、左右のオペランドの評価が終わっていなければ、代入できない。
例えば、「a = b += 5」という式であれば、b + 5の演算が終わらなければ、変数aに値が代入されることはない。

▼マイナス演算子
・マイナス演算子「-」は、左オペランドから右オペランドの値を引く「二項演算子」と、
正負の値を反転させるために使う「単項演算子」の2種類が存在する。
二項演算子↓
10 - 2;
単項演算子↓
-10
※マイナス演算子とオペランドの間に空白が存在しても、正常に反転される↓
- 10  ←OK

▼2進数の計算
・2進数で表記されている値は以下のように計算が出来る↓
【2進数表記から10進数表記への計算】
010010010
↑のような2進数での表記があった場合、右ビットから1,2,4,8,16...のように2乗した値を当てはめる。
ビット値が1となっている桁に当てはまる2乗した値の合計を求める
2 + 16 + 128 = 146
上記の2進数の結果は146となる。

▼数値のキャスト
・大きな範囲の値を小さな変数に代入する際は下記のような明示的な「キャスト」を行う必要がある↓
【明示的な型変換(キャスト)のサンプル】
int a = 10;
short b = (short) a;

・整数や浮動小数点数といった数値リテラルは、デフォルトで特定の型を持っている。
整数のリテラルはint型、浮動小数値はdouble型がデフォルトである。
その為下記の式は本来であれば明示的なキャストをしなければならないことになる↓

short b = 10;   //int型の数値リテラルをshort型に代入しようとしている。

しかし、byteやshort型の変数に代入する整数リテラルの場合、その値が型の範囲内であればコンパイラはエラーを出さない。
byteは-128〜127の範囲を扱うことが出来る。
byte a = 128;   //byte型の範囲に収まらないint型のリテラルのためコンパイルエラー
byte b = 127;   //byte型の範囲に収まるint型のリテラルのためコンパイル可能
・byte型の範囲を超える値でも以下のように明示的にキャストすることでコンパイルエラーが起こらなくなる↓
【byte型の範囲を超えるint型のリテラルをキャストして代入】
byte b = (byte)10000;   // byte型は-128〜127の数値データしか扱えないため、正しい結果を得ることはできない。

・数値を演算する際、演算子の左右のオペランドは同じ型でなければならない。
オペランドの型が異なる場合、小さい方の型へ大きい方の型へ自動的に変換される(暗黙的な変換)↓
【暗黙的な変換(キャスト)のサンプル】
int a = 10;      //int型変数aに10を代入
long b = 20;     //long型の変数bに20を代入
long c = a + b;  //intとlong型の変数で加算。この際int型変数aは自動的(暗黙的)にlong型に変換される。
※long型同士で演算を行った結果はlong型となり、int型変数に代入できないことに注意。

・整数リテラルのデフォルト値はint型、浮動小数点リテラルのデフォルトはdouble型↓
【double型の浮動小数点リテラルをfloatに代入するサンプル】
float a = 3.14;   //float型の変数により大きい型であるdouble型のリテラルを代入している為コンパイルエラー
float b = (float)3.14;  //このようにキャストすればコンパイルエラーが起こらない
float c = 3.14F   //基本的に上記のようにせずこちらのように接尾辞を付加してfloat値であることを明示的に宣言する。

▼互換性のないキャスト
・Javaではbyte型のような数値型とboolean型に互換性はない。
byte型にboolean型の真偽値(true/false)を代入したり、boolean型にbyte型の0や1を代入することは出来ない。
他の言語では互換性があったりするので注意。

▼インクリメントとデクリメント
・インクリメント演算子「++」デクリメント演算子「--」は変数の値に1を加算したり減算したりするための演算子。
この演算子は以下のように単独で記述した場合、単に1を加算・減算するシンプルな動作をする↓
【単純なインクリメント】
int a = 10;
int b = ++a; //前置インクリメント 「int b = 1 + 10」と同じ動作
int c = a++; //後置インクリメント  元の値である11が先にcに代入され、その後変数aがインクリメントされる。

・インクリメントは他の演算を追加しながら、行われる場合もある↓
【少し複雑なインクリメント】
int a = 10;
int b = a++ + 10; //int b = 10 + 10; (20) a = 10 + 1 (11) 
//この場合も元の値をコピーして演算してから、aの値をインクリメントする。
//変数bの値は20 変数aの値は11となる。

・上記のように変数が2つに分かれている場合は少しわかりやすいが、下記のように1つの変数を使う場合もある↓
【複雑なインクリメント】
int a = 10;
a = a++ + a; //a = 10 + 11 (21)
// 先にインクリメントをしてから式を組み立てると、より単純にすることができる。
// 先にインクリメントをしてから式を組み立てるのはこれらの演算子の優先順位が他の算術演算子よりも高いからである。
// インクリメント演算子・デクリメント演算子と算術演算子の優先順位は異なるため、注意が必要

・また、インクリメントされた結果は演算子の後に出てくる変数に適用されることにも注意が必要。↓
【複雑なインクリメント】
int a = 10;
a = a++ + a + a; //a = 10 + 11 + 11 (32)

・前置インクリメントの場合でもインクリメントされた一時変数が適用されるタイミングが異なるだけで、
「インクリメントされた結果は演算子のあとに出てくる変数に適用される」というルールは同じ↓
【複雑なインクリメント】
int a = 10;
a = ++a + a + a; // a = 11 + 11 + 11 (33)

・また、下記のように複数インクリメント演算子やデクリメント演算子がある場合、
演算子が出てきたタイミングで一時変数の値を変更して、適用していく↓
【複雑なインクリメント】
int a = 10;
a = a++ + a ++a + a //a = 10 + 11 + 12 + 12 (45)

・演算子が出てきたタイミングで一時変数の値を変更し、それ以降に登場する変数にも適用するというルールを覚えておけば、
下記のような複雑な式も比較的に単純に解くことが出来る↓
【複雑なインクリメント】
int a = 10;
a = a++ + a + a-- - a-- + ++a; //a = 10 + 11 + 11 - 10 + 10 (32)

▼関係演算子
・関係演算子は、左右オペランドの値を比較し、真偽値を戻す演算子。
演算子      使用例          意味
==          a == b          aとbが等しければtrue
!=          a != b          aとbが等しくなければtrue
>           a > b           bがaより小さければtrue
>=          a >= b          bがa以下であればtrue
<           a < b           bがaより大きければtrue
<=          a <= b          bがa以上であればtrue
instanceOf  a instanceOf b  aがbと同じクラスかbのサブクラスのインスタンスであればtrue
※これらの演算子は、数値や文字、真偽値、参照など様々な対象を比較できる。
しかし、このうち「>」「<」「>=」「<=」の4つの演算子は、数値の大小を比較する演算子のため、数値以外の比較は出来ない。

▼論理演算子
・論理演算子は関係演算子を組み合わせ、複雑な条件を指定するために使う。
論理演算子を使用し、「10より大きく、かつ20より小さい」や「xは10と等しいか、またはyは20と等しいか」
などのような複雑な条件を記述可能となる。
演算子      使用例          意味
&           a & b           aとbの両方がtrueであればtrue
&&          a && b          aとbの両方がtrueであればtrue
|           a | b           aもしくはbのいずれかがtrueであればtrue
||          a || b          aもしくはbのいずれかがtrueであればtrue
!           !a              aがfalseであればtrue(trueであればfalse)

・「&」と「&&」「|」と「||」の違いは、左オペランドの結果で右オペランドを評価するか、評価するかの違いである。
「&&」と「||」は「ショートサーキット演算子」と呼ばれ、左オペランドの結果によっては、右オペランドの評価を飛ばす。
「&&」はもし左オペランドの式がfalseを戻した場合、右オペランドを評価しない。
左オペランドの結果がfalseであった場合、右オペランドがいずれの結果にせよ、判定結果はfalseとなるためである。
「||」はもし左オペランドの式がtrueであった場合、右オペランドを評価しない。
左オペランドがtrueであった場合、右オペランドがいずれの結果にせよ、判定結果はtrueとなるためである↓
【ショートサーキット演算子のサンプル】
int a = 5;
boolean b = a < 3 && ++a < 10;  //右オペランドで行われるインクリメントは処理されず飛ばされる。

・両オペランドの評価をしたい場合は、「&」または「|」を利用する
【&演算子を利用した式】
int a = 5;
boolean b = a < 3 & ++a <10;  //結果はfalseとなり、上記のサンプルと同じだが、右オペランドの評価が行われる為、
                              //変数aへのインクリメントが適用され、aの値が6となる。
▼演算子の優先順位
・Javaのプログラムでは、複数の演算子を組み合わせて複雑な式を表現できる。
演算子には優先順位があり、同じ優先順位であれば式は左から順に実行される。
もし異なる優先順位の演算子が含まれている場合、優先順位が高いものから演算される。
演算子の優先順位は以下の通り↓

優先順位                演算子
高い                    [], ., (パラメータのリスト), x++, x--
｜                      ++x, --x, ‾, !
｜                      new, (型)x
｜                      *, /, %
｜                      +, -
｜                      <<, >>, >>>
｜                      <, >, <=, >=, instanceOf
｜                      ==, !=
｜                      &
｜                      ^
｜                      |
｜                      &&
｜                      ||
↓                      ?:
低い                    =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=
※Javaには数多くの演算子が存在しており、それぞれ優先順位が異なる。
全て覚えようとすると大変なので、以下の要点を抑える。
()やインクリメント、デクリメントが最優先である。
・数学と同じで、乗算や徐算、剰余残が、加算や減算より優先である。

■基本型と参照型について
・Javaの型には、「基本型」と「参照型」が存在する。
▼リテラル
・リテラルとはソースコード上に記述する値の事。
・Javaには、「整数」、「浮動小数点」、「真偽」、「文字」
の四種類のリテラルが存在する。
それぞれのリテラルにはデフォルトの型が存在し、
整数であればint 浮動小数値であればdouble 真偽値であればboolean 文字であればchar のデータとして扱われる。
リテラルを他のデータ型であることを明示したい場合、longであれば「L」または「l」 floatであれば「F」または「f」
のように接尾辞を値の後ろに付ける。
byteとshortには接尾辞は存在せず。
short sh = 10;
のようにint型のリテラルを代入した際にも、宣言した型に応じて自動的に変換が行われる。

▼整数リテラルの記述種類
・整数リテラルの記述は、10進数(decimal number)のほか、
8進数(octal number)、接頭辞「0」 範囲[0 〜 7]
16進数(hexadecimal number)、接頭辞「0x」 範囲[0 〜 F]
2進数(binary number)、接頭辞 「0b」 範囲[0 〜 1]
での記述も可能。
例えば10進数の「63」を8進数で記述する場合は「077」のように「0」を接頭辞に付ける。
16進数であれば「0x003F」のように「0x」を接頭辞に、
2進数であれば、「0b0111111」のように「0b」を接頭辞に付ける。

▼リテラル表記に使用可能な記号
・アンダースコア「_」が桁数が多い数字の可読性向上の目的でJavaSE7から記述可能。
以下の2ルールに沿えば自由にリテラルに記述できる。
1,リテラルの先頭と末尾には記述不可
2,記号の前後には記述不可(アンダースコア「_」を「＿＿＿」のように連続で記述するのはOK)

2のルールには少数点を表す「.」
long型とfloat型に用いる「L」や「F」
2進数や16進数を表す「0b」や「0x」なども記号として含まれるので注意する。

▼基本型(プリミティブデータタイプ)
基本型には8種類のデータ型が存在し、それぞれ代入出来るリテラルや値の範囲が異なる。
byte    ... 範囲 -128 〜 127の整数値    サイズ 1byte  初期値 0
short   ... 範囲 -32768 〜 32677の整数値    サイズ 2byte  初期値 0
int     ... 範囲 -2147483648 〜 2147483648の整数値  サイズ 4byte  初期値 0
long    ... 範囲 -9223372036854775808 〜 9223372036854775807の整数値   サイズ 8byte  初期値 0
char    ... 範囲 Unicode文字1文字   サイズ 2byte  初期値 ''or Unicodeの0
float   ... 範囲 ±3.40E38〜±1.40E45 の浮動小数値  サイズ 4byte  初期値 0.0
double  ... 範囲 ±4.94E-324〜±1.79E+308の浮動小数値  サイズ 8byte  初期値 0.0
boolean ... 範囲 trueかfalseの真偽値   サイズ 1bit   初期値 false

▼変数名の記述規約
・変数を宣言する際の変数名は、以下のルールに沿っている必要がある。
1,すべてのUnicode文字が使用可能 ※日本語など(マルチバイト文字)も使用可能だが可読性が落ちる為推奨されない。
2,英数字が使用可能
3,アンダースコア「_」が使用可能
4,ドルマーク「$」が使用可能(基本使わない)
4,先頭に数字は使用不可(コンパイルエラー)
5,文字数制限はない
6,大文字と小文字は区別される
7,予約語は使用不可(コンパイルエラー)

▼char型
・文字を1文字代入可能なデータ型
・1文字とは「あ」や「え」などの一文字ではなく、Unicode文字と呼ばれる文字コードの1つを許容している。
・Unicodeとは無数に存在する文字コードの中、javaで利用される文字コードの一種。
・Unicodeでは、1つ1つの文字を[0 〜 65535]の番号に当てはめて表現している。
・なので実際char型は内部で、2バイトの符号なし整数を許容している。
・例としてアルファベットの「A」はUnicodeの文字コードで「65」で表現可能
・16進数での指定も可能
・16進数をシングルクォートで囲った記述も可能。その際は、Unicodeエスケープ「¥u」を利用する。
char ch1 = 'A'     //直接1文字のリテラルをシングルクォートで代入
char ch2 = 65      //Unicode文字で指定
char ch3 = 0x0041  //16進数で指定
char ch4 = '¥u0041'//シングルクォートで囲い、Unicodeエスケープ「¥u」を記述し16進数で指定
↑全て結果は同じ。「A」が代入される。
※char型には文字列を表現するダブルクォーテーション「""」は使用できない為注意。
※負の整数をリテラルとして指定するとコンパイルエラーとなる。

▼参照型(リファレンスタイプ)
・参照型はオブジェクトへの参照(リンク)を保持する。
・参照型の変数はオブジェクトへの参照(リンク)を保持しているか、していないかのみ表現可能。
・オブジェクトへの参照(リンク)を保持していない事を表すのが「null」
・インスタンスからインスタンスへ代入が行われた場合、
代入元のインスタンスは参照先を代入先のインスタンスへ切り替える。
その為、元々参照していたインスタンスへの参照がなくなる。(ガベージコレクションの対象となる)

▼インスタンス
・javaのオブジェクト指向型プログラミングでは、
クラスを定義し、クラスからインスタンスを生成、生成したインスタンスを動作させることでプログラムを実行させる。
・クラスは定義しただけでは動作せず、インスタンスを生成する事で動作する。
・クラスとインスタンスの関係はコピー元とコピーの関係と同じようなもの
クラスファイルはハードディスク上に保存されている単なるファイル過ぎない。
プログラムはハードディスク上では動作不能なため、メモリ上に展開する必要がある。
JVM(Java Vartual Machine)は必要なクラスファイルをハードディスク上から探し出し、
読み込んでメモリ上に展開(コピー)する。このコピーがインスタンス。
その為インスタンスはクラスに定義した内容をそのまま保持している。
※コピーという表現を使っているが、厳密にいえば完全なるコピーが作られるわけでは無い。
例として、クラス変数や、メソッド(staticメンバ)などはインスタンスへコピーされない。

▼同一と同値
・Javaでは「同じ」という言葉が2つの意味を持つ。
1つ目は、同じインスタンスであること。
2つ目は、同じ値であること。
前者を「同一」、後者を「同値」と呼ぶ。
同一であるとは、複数の変数が同じインスタンスを参照していることを指す。
例として、下記のコードはインスタンスを1つ生成し、そのインスタンスへの参照を2つの変数で共有している↓
【2つの変数に同じインスタンスを参照させるサンプル】
Object a = new Object();
Object b = a; //変数aの参照を変数bにコピーして代入。このような状態が「同一」

・同一性の判定は「==」演算子で行う。次のコードは上記のコードで生成したインスタンスの同一性を比較している。
【インスタンスの同一性を判定するサンプル】
boolean flg = a == b; //どちらも同じ参照を持っているため、「true」が代入される。

・次に「同値性」
同値性とは、インスタンスは異なるが、同じ値を持っている性質の事を指す。
以下のようなクラスを例に同値性について記述↓
【インスタンスの型となるクラス(Personクラス)】
public class Person{
	private String name;           //String型のnameフィールド
	public Person(String name) {   //nameを初期値に設定するコンストラクタ
	this.name = name;              //引数のパラメータをフィールドにセット
	}
}
//上記のクラスを使い、同じ値を持つ2つの異なるインスタンスを生成する。
【同値を持つ異なるインスタンスを生成】
Person a = new Person("taro");
Person b = new Person("taro");   //new演算子は、新たなメモリ領域を確保する演算子なので、
                                 //この2つのインスタンスは異なる参照を持つインスタンスとなる。

・インスタンスを2つ生成し、それぞれ異なる変数に代入しているため、それぞれの変数が持つ参照は異なる。
しかし、参照先のインスタンスは共に同じ値を保持している。このような状態が「同値」
・同値性は同一性のように「==」演算子で比較することが出来ない。
「==」演算子は変数内の値、つまりは参照同士を比較する演算子であるためである。
参照先にあるインスタンスが同じ値を保持しているかどうかは「equals」メソッドを使用して確認する。
・「equals」メソッドはObjectクラスに定義された、同値性を判定するためのメソッドである。
ただし、Objectクラスに定義されたequalsメソッドは下記のように同一性を確認する実装となっている↓
【Objectクラスのequalsメソッド】
public boolean equals(Object obj){
	return (this == obj);
}

・「同じ値を持っている」という定義は、すべてのフィールドが一致することを指すのか、
一部のフィールドのみでも一致とするかなどの判断は設計者に委ねられている。
クラスを設計するにあたっては、同値であることの条件を定め、equalsメソッドを「オーバーライド」する事で実装を行う。
※オーバーライドとオーバーロードの違いに注意
equalsメソッドはオーバーライドして使用されることを前提として実装されているが、
引数をObject型とせず、他の型でequalsメソッドを定義した場合、
メソッドの「オーバーロード」となってしまい、別のメソッドとして実装されてしまう。

・equalsメソッドは、同値性を確認するためのメソッドであり、Objectクラスで定義されたメソッドであるため、
すべてのクラスが引き継いでいるメソッドとなる。(全てのクラスは、Objectクラスを暗黙的に継承している)
equalsメソッドはオーバーライドして使用することを前提として実装されているが、
このメソッドをオーバーライドする際は下記の条件を満たしてなければならない。
1,null以外の参照値xがあった時、x.equals(x)はtrueを返す事。
2,null以外の参照値xとyがあった時、y.equals(x) == true の場合 x.equals(y) == true である事。
3,null以外の参照値xとy,zがあった時、y.equals(x) && y.equals(z) == trueの場合、 
の場合 x.equals(z) == true である事。
4,null以外の参照値xとyがあった時、x.equals(y)を複数回呼び出されても、値の変更がない限り一貫した判定結果を返すこと。
5null以外の参照値xについて、x.eauals(null)はfalseを返す事。

・これらの条件は公式のAPIドキュメントに掲載されている条件であり、試験の対策とする際5は確実に覚えておく。


■GC(ガベージコレクション)について
▼ヒープ領域へのガベージコレクト
・インスタンスはメモリ上に生成されるため、無制限に生成するとメモリ空間を使い切ってしまう。
限りあるメモリを有効に使うために、利用されないインスタンスを削除し、空きスペースを作る必要がある。
・C言語などでは、メモリを確保したり、解放したりするコードをプログラムに記述しなければならない。
このようなメモリ操作は、プログラムからハードウェアを自由に扱える高い自由度を与えてくれる反面、
コーディングの煩雑さや、バグフィックスの複雑さなど、ソフトウェア開発の生産性を左右する大きな障害となりうる。
・Javaでは自動メモリ管理機能が提供されており、メモリ操作といった煩雑なコーディングからプログラマを解放し、
高い生産性を維持できる言語として設定されている。
・利用されなくなったインスタンスを解放するのは、
JVM(Java Vartual Machine)の機能の1つであるガベージコレクタが行う。
ガベージコレクタは、メモリ上使われなくなったインスタンスがいないか探し、
見つかればそのインスタンスを破棄して、メモリを解放する。
また、ガベージコレクタは、インスタンスの破棄を繰り返すことで細切れになったメモリをまとめ、
大きな空間を確保する「コンパクション」という機能を持っている。
・ガベージコレクタが不要なインスタンスを探しだし、破棄する事を「ガベージコレクト」と呼ぶ。
・ガベージコレクションが発生するタイミングをプログラマが制御することは出来ず、
CPU(Central Processing Unit)の利用状況などによってJVMが決める。
・Systemクラスにはgcメソッドというガベージコレクションを促すメソッドが存在するが、
これはJVMに実行を促すだけであり、
必ずガベージコレクトが起きる事を保証するものではない。
・ガベージコレクトの対象は、どこからも参照されなくなったインスタンス。
インスタンスへの参照が外れる代表的なタイミングとしてはnullを代入するときがある。
Object obj = new Object(); //インスタンス化
obj = null;                //このタイミングで、インスタンスへの参照が外れる。
・上記以外にも、インスタンスへの参照を保持している変数に、他のインスタンスへの参照を代入した時も同様


■修飾子
▼ final修飾子について
・フィールド、メソッド、クラスに付与可能。しかし、それぞれ挙動が異なる。
フィールドに指定 → そのフィールドの値の上書きを禁止
メソッドに指定　 → サブクラスでのメソッドのオーバーライドを禁止
クラスに指定 　　→ クラスのサブクラス化(継承)を禁止

▼ アクセス修飾子について
フィールド、メソッド、クラス、コンストラクタに付与可能。
         アクセスレベル　　低　ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー＞ 高
             |public                         |protected                                   |なし                               |private
フィールド     |全てのパッケージから参照可能        |同パッケージ内、親子関係のあるクラスから参照可能     |同パッケージ内から参照可能             |同クラス内でのみ参照可能
メソッド　     |全てのパッケージから参照可能        |同パッケージ内、親子関係のあるクラスから参照可能     |同パッケージ内から参照可能             |同クラス内でのみ参照可能
クラス　　     |全てのパッケージから参照可能        |コンパイルエラー                               |同パッケージ内から参照可能　　　　　　　　|コンパイルエラー
コンストラクタ　|全てのパッケージから参照可能        |同パッケージ内、親子関係のあるクラスから参照可能     |同パッケージ内から参照可能             |同クラス内でのみ参照可能

特にアクセス修飾子を付与しない場合のフィールドやメソッドはprotected修飾子を付与する時よりアクセス制限が高くなることに注意。

■キャスト
▼ ワイドニング変換(アップキャスト)とナローイング変換(ダウンキャスト)について
・ワイドニング変換(アップキャスト)
値のサイズの小さい方から大きい方へ変換すること。
「暗黙的キャスト」によって行われる。
サイズの小さいプリミティブ型からサイズの大きいプリミティブ型へ値を代入する際には、データの変換が行われる。サイズが異なるため、そのままでは代入が不可能であるためである。
特にコーディングの際に意識をせずとも自動的に行われるが、変換が内部で行われている事は覚えておく。

・ナローイング変換(ダウンキャスト)
値のサイズの大きい方から小さい方へ変換すること。
「明示的キャスト」によって行われる。
サイズの大きいプリミティブ型からサイズの小さいプリミティブ型へ値を代入する際には、データの変換が行われる。サイズが異なるため、そのままでは代入が不可能であるためである。
出来るだけ避けるべき変換であり、理由としては、
サイズの大きい型の値から小さい方へ値がキャストされるため、小さい型で表現できない値が入ってくる事があり、その際数値であれば数値の切り落としや正負反転が行われる等、正しい結果を得る事ができなくなるためである。
記述の方法は「([変換したい型])[変換したい変数]」←のように、()に変換後の型を記述し、その右側に変換したい変数を記述することでナローイング変換が行われる。
また、互換性のない参照型変換を行うと、ClassCastExceptionが発生するので、関係性をよく確認する。

▼ オートボクシングとアンボクシング
Java 5.0からプリミティブ型とラッパークラス間の自動変換が行われ、お互いの代入や演算が可能となっている。
プリミティブ型　→　ラッパークラスへ自動変換     ... オートボクシング
ラッパークラス　→　プリミティブ型へ自動変換     ... アンボクシング

■制御構文について
▼ for文
・for文の初期化式には複数の変数を宣言可能だが、複数宣言する際型は全て同じでなければならない。
・for文の初期化式、条件式、変化式の中で、カンマ区切りで複数記述出来るのは初期化式と変化式のみ。条件式は複数宣言することができない。

▼if文
・if文は波カッコ({})を省略した記述が可能(可読性が落ちるため推奨されない)
・波カッコ({})を省略した場合、次の1文だけが条件に合致した場合の処理として実行される。
・試験では波カッコを省略したパターンのif文の問題が出題される事があるので波カッコを追記するようにする↓
【波カッコ({})を省略したif文】
 if(false)
 	 System.out.println("A"); 
 	 System.out.println("B"); //結果は"B"が出力される。仕組みは以下と同じ↓
【上記のif文に波カッコを追記したパターン】
 if(false){
	 System.out.println("A"); //判定がfalseであるため処理が行われない
 }
 System.out.println("B"); //上記の処理を抜け、"B"が出力される。

■switch文の許容条件式と、case値の許容値
・switch文は条件式が戻す値と一致するcase式を実行する。
条件式が戻せる値の型には制限があり、条件式は次の型の値を戻す式でなければならない。
char
byte
short
int
Character
Byte
Short
Integer
String
enum

・次のように覚えるとよい
int型以下の整数型とそのラッパークラス(byte,short,int,Byte,Short,Integer)
文字と文字列(char,Character,String)
列挙型(enum)
※long型が条件式として許容されない事に注意!

・switch文のcase値として使用できる値は以下の条件を満たしている必要がある
条件式が戻す値と同じ型か互換性のある型であること
定数であるか、コンパイル時に値を決めることが出来ること
nullでないこと

※特に注意すべきは�Aの定数である事
これは、final宣言された変数又は、リテラルであること表す。
その他の変数はcase値としては使用不可。
変数はプログラム実行中に値が再代入される可能性があり、複数のcase値が同じ値になってしまい、
分岐処理が成り立たなくなる可能性があるためである。

■三項演算子について
・三項演算子は条件に合致するかどうかで戻す値を変更する演算子。
この演算子の書式は以下の通り↓
真偽値式 ? trueの場合に評価する式 : falseの場合に評価する式
コード上で記述する書式としては以下の通りとなる↓
【三項演算子を利用した代入】
int a = 10;
int b = a == 10 ? a : 0; //変数aの値が10であるかを判定し、trueであれば変数aの値を、falseであれば0を戻す
System.out.println(b);   //条件式がtrueであるため、変数aの値である10が変数bに代入される。

・ネストした三項演算子
三項演算子は代入を行う分岐を行う際に、if文などの条件分岐文使用するより、
無駄なインデントによりプログラムの階層が深くなり、可読性の低下を抑える事ができるので便利だが、
ネストした三項演算子は可読性が低いため、推奨されていない↓
【ネストされた三項演算子のサンプル】
int point = 80;
String val = point < 40 ? "D" : point < 60 ? "C" : point < 80 ? "B" : "A"; //ネストされた三項演算子
System.out.println(val); // "A"が出力される。

■メソッドについて
▼ 呼び出し
・引数がアップキャスト可能である場合、自動変換される。long型の値を引数に取るメソッドにint型の数値を渡して起動してもコンパイルエラーとならないので注意。
・変換可能な関係を持つ引数を受け取るメソッドが2つ以上定義されている場合、片方がlong型で片方がint型であれば、渡された引数の型と一致するメソッドが起動される。
・メソッドの戻り値に対して、メソッドを呼び出すことを「メソッドチェイン」と呼ぶ。→ str.subString(1,3).replace("b","c");   (「subString」の結果に対して「replace」で置換を行っている。)

▼シグニチャ
・プログラムからメソッドを呼び出す際、JVM(Java Vartual Machine)は指定されたメソッドを読み込み、実行する。
・JVMは多数あるメソッドの中から実行すべきメソッドを探し出す方法が必要。
・以下の3つの方法で探し出す。

1,参照(どのインスタンスのメソッドか)
2,クラス名(どのクラスで定義されているのか。(static))
3,シグニチャ

・参照やクラス名はどこに定義されているメソッドなのかを見分ける為に必要。
これらが省略されている場合、コンパイラは同じクラスや同じインスタンスに定義されているメソッドだと解釈する。
・シグニチャとは、メソッド名と引数のリストのセットの事。
JVMはメソッドの名前のみで読み込み先のメソッドを見分けているのではなく、
引数の型や数も参照し、実行している。
Javaには「オーバーロード」という仕組みが存在し、同名のメソッドが複数存在している可能性があるため、
異なる引数を受け取る同名のメソッドは別のメソッドであると判断する。

▼ 可変長引数
・可変長引数の宣言方法は引数の型の直後にピリオド3つ「int... values」となる。
・可変長引数以外の引数を同時に受け取る必要がある場合、どこまでが固定長と可変長の引数かわからなくなるため、可変長引数は最後の引数としなければならない。
・可変長引数はJVMによって配列に置き換えられる。そのため、可変長引数を使用する際は配列と同じように[]で値にアクセスする必要がある。
・同じ型の数が可変な引数をまとめられるだけで、異なる型はまとめられない。

▼ オーバーロード
・オーバーロードされたメソッドが定義されており、どちらのメソッドも同時に起動出来る引数を渡してメソッドを呼び出すと、「あいまいなメソッドの呼び出し」としてコンパイルエラーとなる。
・オーバーロードはシグニチャ(メソッド名、引数の数、引数の順番のセット)が異ならなければ適用されない。

▼ オーバーライド
・オーバーライドするメソッドはメソッド名、シグニチャが同じでなければならない。
・戻り値は原則として同じでなければならないが、Java5から「共変戻り値」が導入されたことにより、戻り値に定義された型のサブクラスであればオーバーライドしたメソッドも戻り値型に指定可能。
・オーバーライド(Override)はOverwrite(上書き)と勘違いされがちなため注意。スーパークラスの定義を上書いているのではなく、サブクラスに新しい定義を追加(再定義)している。
スーパークラスに定義されたメソッドと、サブクラスにオーバーライドされたメソッドの両方が同時に存在している状態となる。
・オーバーライドが再定義なのに対し、オーバーロードは全く新しいメソッドを多重定義しているので混合しないよう注意。
・オーバーライドしたメソッドはスーパークラスのメソッドより高いレベル(硬い)アクセス修飾子を付与する事が出来ない。protectedで宣言されたスーパークラスのメソッドをオーバーライドする際は、「protected」か「public」のみ付与することが可能。


▼ コンストラクタ
・初期化ブロックはコンストラクタが実行される前に実行される。

■変数について
▼ フィールド
・フィールドとローカル変数で同じ変数が宣言されていた場合、ローカル変数のスコープ範囲内であれば、ローカル変数の値が優先的に使用される。フィールドの値を使う場合は明示的に「this」を使用しなければならない。
・スーパークラスのフィールドにアクセスする際は、「super」を使用する。省略は可能だが、同名のフィールドが定義されていた場合、明示的に記述しなければローカル変数やサブクラス内のフィールドが優先される。

■配列について
・配列は共通した複数のデータを一つの変数をまとめる際に使用するデータの集まりを扱う配列クラスのインスタンス。
・Javaにおいて配列とはただのデータの集まりの事を指すのではなく、データの集まりを扱うインスタンスである事に注意。
・配列クラスは言語使用に組み込まれているため、実装コードを確認することはできないが、その他クラスと同様にnew宣言をし、インスタンスを生成してから操作可能となる。
・配列には以下の特徴が存在する。
1,同じ型、または互換性のある型の値しか扱えない
2,扱える要素数はインスタンス生成時に決定する。あとから要素数を追加することはできない。
例えば、複数の生徒のテスト得点などを
int a = 80, b = 68, c = 91, d = 77....
のように複数初期化していくと管理が煩雑化する為、配列として1つの変数にまとめる事で、管理しやすくなるなどのメリットを得る事が出来る。

▼配列の宣言と要素数の指定
・配列を宣言する際は以下のように行う。
配列型名[] 配列変数名;
・また、以下の方法でも同様に宣言可能。
配列型名 配列変数名[];
以下がサンプル↓
【配列の宣言(サンプル)】
int[] array;     
int array[];     //どちらでも宣言可能

・配列を生成する際は要素数を指定する必要がある。
配列変数名 = new 配列型名[要素数];
・また、宣言と要素数の指定を同時に行う事が出来る↓
【配列の宣言と要素数の指定】
int[] a;
a = new int[5];       //宣言と要素数の指定を分けた場合

int[] b = new int[5]; //宣言と要素数の指定を同時に行った場合。

※new int[0];
としても文法上エラーは発生しないが、何も役割を持たない配列となる。

▼配列の要素への値の代入と参照
・要素数を指定した配列には各要素への値の代入が可能となる。
配列名[インデックス] = 値;
・インデックスとは要素に割り振られた番号の事。
例えば5つの要素数を持つ配列を生成した場合、その配列には5つのインデックスが割り振られ、その要素にアクセスする際に使用する。
【配列の要素へアクセスし、値を代入】
int[] array = new int[5];
array[0] = 1;
array[1] = 2;
array[2] = 3;
array[3] = 4;
array[4] = 5; //5つの要素数を持つ配列を生成した場合、0〜4のインデックスが割り振られる。

System.out.println(array[3]);  //要素へアクセスし、参照を行う際も同様にインデックスを指定する。結果は「4」となる。

※上記のような参照を行う際、
System.out.println(array);
とすると、配列の要素ではなく、メモリ上に割り振られた配列のハッシュコード値が戻される為注意。(配列自体は参照型)
※配列のインデックスは「0」から始まることに注意する。
※配列の要素に値を代入しなかった場合、基本型の配列であればそれぞれの初期値がデフォルト値として代入されている。(参照型の配列であれば「null」)
※通常のインスタンスと配列インスタンスを混合しないよう注意する。配列インスタンスはnewで宣言しただけでは要素が生成されず、代入するまで参照型であれば「null」が代入されている↓
【配列インスタンス生成時の注意】
public class SomeClass{
	int price = 100;
}
public class SomeClassWithArray{
	public static void main(String[] argus){
		SomeClass[] array = new SomeClass[3];	//SomeClassのインスタンスではなく、配列インスタンスであるため、この段階でまだ要素内は「null」
		System.out.println(array[0].price);		//「null」要素からフィールドにアクセスしようとしているため、「nullPointerException」となる。
	}
}

・配列も基本型の変数と同様に宣言と値の代入を同時に行う事が出来る
配列型名[] 配列変数名 = {値1,値2,値3,...};
【配列の生成と値の代入を同時に行う初期化方法】
int[] arrayA = {1,2,3,4,5};             //コンパイル可能。({})内に","で区切った数分の値分の要素数が自動的に生成される。
int[] arrayB = new int[]{1,2,3,4,5};	//コンパイル可能。要素数は自動計算される
int[] arrayC = {};						//コンパイル可能。int[]array = new int[0];と同様に何も役割を持たない配列となる。
int[] arrayD = new int[5]{1,2,3,4,5};	//コンパイルエラー。初期化演算子({})を記述しながらnew演算子を記述した場合、角括弧内に要素数を指定してはいけない。

▼Arrays.fillメソッド
・Arraysクラスのfillメソッドを使用する事により、配列の全要素に同値を代入する際に簡潔に記述する事が可能
Arrays.fill(配列変数名,値);
で利用可能。

【Arrays.fillのサンプル】
int[] array = new int[5];
Arrays.fill(array,3);     //メソッドを(配列変数名,値)で呼び出し
for(int num : array){
	System.out.print(num);  //結果は「33333」となる。
}

▼Arrays.sortメソッド
・Arraysクラスのsortメソッドを使用する事により、配列の要素を昇順や降順に並び替える事が可能
Arrays.sort(配列名);
・上記の記述で昇順に要素が並び替えられる。
逆に降順にしたい場合、以下のように記述する。
Arrays.sort(配列名, Collections.reverseOrder());
※Collectionsクラスを使用する際、基本型で宣言された配列を引数に渡すとコンパイルエラーとなる為注意。
int型の配列など基本型の配列には使えない。
【Arrays.sortのサンプル】
int[]array = {3,1,5,4,2};
Arrays.sort(array);
for(int num : array){
	System.out.print(num);	//昇順で並び変えられ、「12345」と出力
}
System.out.println();
Integer[] reversedArray = {3,1,5,4,2};	//基本型配列で宣言すると「Collections.reverseOrder()」メソッドが使用できない為、ラッパークラスで宣言
Arrays.sort(reversedArray, Collections.reverseOrder());
for(int num : reversedArray){
	System.out.print(num);	//降順で並び変えられ、「54321」と出力
}

▼要素数(length)
・配列の要素数を取得する際は、「length」を使用する。
lengthはメソッドでもフィールドでもない配列用の特別な構文である。
配列変数名.length
でint型の配列の要素数が返却される。
・配列の要素数は配列を扱う上で重要になる。
繰り返し処理などで、「配列の要素数分〜を行う」などといった命令を行う際に利用できる為である。
【配列の要素数(length)のサンプル】
int[] array = new int[5];
int num = array.length;    //要素数がint型の数値として返却される。
System.out.println(num);   //配列の要素数である「5」が出力される。
Arrays.fill(array,2);
for(int i = 0; i < array.length; i++){
	System.out.print(array[i]);	//for文の繰り返し条件として「length」を利用。配列の要素数分処理が繰り返され、「22222」が出力される。
}

▼System.arraycopyメソッド
・Systemクラスのarraycopyメソッドを使用する事により、固定長である配列の要素数を追加する事が出来る。※厳密には追加ではなく要素数がより多い配列へ値をコピーする。
System.arraycopy(コピー元配列, コピー元配列のコピー開始位置, コピー先配列, コピー先配列の開始位置, コピーの個数)
以下が要素数を5個増やしたい場合のサンプル
【System.arraycopyのサンプル】
int[] oldArray = {1,2,3,4,5};
int[] newArray = new int[10];   //値のコピー先となる配列を生成
System.arraycopy(oldArray, 0, newArray, 0, 5); //コピー元配列の開始インデックスとコピー先配列の開始インデックスを指定し、最後にコピー元からいくつの値をコピーするか指定。
for(int num : newArray){
	System.out.print(num);    //コピー元の値がコピーされ、結果は「1234500000」となる
}

※このように実装可能であるが、この方法はあまり推奨されていない(固定長配列の要素数を追加する事自体が推奨されない)
上記サンプルのように、要素数の小さい配列であればあまり問題ないが、要素数が増えれば増える程無駄にメモリを消費してしまうからである。
なのでこういった実装を行いたい場合、固定長配列を使用せず、可変長配列(コレクション)を使用するようにする。
あくまで配列は要素数が確定している場合に使用するのが基本である。

▼配列のクローン_cloneメソッド
・配列そのものをコピーする方法は、上記のSystem.arraycopyメソッドでも行えるが、要素をコピーするだけの用途であれば、「cloneメソッド」を使用できる。
配列変数名.clone();
要素数も値も全く同じのコピーを作成することが可能。
【cloneメソッドのサンプル】
int[] oldArray = {1,2,3,4,5};
int[] newArray = oldArray.clone(); //配列変数oldArrayのコピーを変数配列newArrayに代入
for(int i = 0; i < oldArray.length; i++){
	System.out.print(oldArray[i]); //「12345」が出力される
}
System.out.println();
for(int i = 0; i < newArray.length; i++){
	System.out.print(newArray[i]); //「12345」が出力される
}

※参照そのものがコピーされる訳ではないことに注意。あくまで配列の内容がそのままコピーされる。(シャローコピー)
参照毎コピーする場合、newArray = oldArray とすると、同一のインスタンスを参照する。(ディープコピー)

▼配列型について
・配列は同じ型、または互換性のあるデータの集まりのみを保持できる。
・宣言した配列型に追加する要素は配列型と継承関係、実装関係を持つデータを代入可能。(配列型のサブクラスであれば)
【継承・実装関係を持つデータの代入】
Number[] array = new Number[2];
Number a = 1;
Integer b = 1;
array[0] = a;
array[1] = b;	//NumberクラスはIntegerクラスのスーパークラスであるで、サブクラスであるIntegerクラスの値を代入する事が出来る。
for(Number num : array){
	System.out.println(num);
}

▼2次元配列(多次元配列)
・2次元配列とは、上記までの通常の配列(1次元配列)に次元を1つ追加したもの。
・2次元配列では、上記の1次元配列で複数の値を一つにまとめた配列を1つの値としてさらにまとめ、2次元配列内に格納する事が出来る。
・イメージとしては、1次元配列が横一列だとすれば、そこに縦の列を追加したと考える。
・マンションなどでイメージするとわかりやすい。
1次元配列は、部屋番号[0]番,部屋番号[1]番,部屋番号[2]番,.....
といった形で部屋番号だけを指定していたが、対して、
2次元配列は、[0]階の部屋番号[0]番,[1]階の部屋番号[1]番,[2]階の部屋番号[2]番,....
といった形で階数(1次元配列そのもの)が追加されたと思えばよい。
〇1次元配列を図面で表した例
[0],[1],[2],[3],[4],....

〇2次元配列を図面で表した例
[0][0],[0][1],[0][2],[0][3],[0][4]
[1][0],[1][1],[1][2],[1][3],[1][4]
[2][0],[2][1],[2][2],[2][3],[2][4]
[3][0],[3][1],[3][2],[3][3],[3][4]
[4][0],[4][1],[4][2],[4][3],[4][4]

・1次元配列を1つの値として扱う場合、[0][0]の左側のインデックスを1次元配列そのもの。右側のインデックスを1次元配列内の値とイメージするのが良い。
上記の例では5つの1次元配列を1つの2次元配列として格納しているイメージとなる。

▼2次元配列の宣言と生成
・宣言の方法は1次元配列とほとんど同じである。
配列型名[][] 配列変数名;
・角括弧([])が1次元配列と比べ、1つ追加されるだけである。
・1次元配列と同様に以下のように記述してもコンパイル可能
配列型名 配列変数名[][];
・また、以下記述方法でも宣言可能
配列型名[] 配列変数名[];
サンプル↓
int[][] array;
int array[][]; 
int[] array[];	//いずれのどの記述でもコンパイル可能

・要素数の指定も同じように行う。
配列変数名 = new[要素数(1次元配列の数)][1次元配列内の要素数];
・以下が配列の宣言と要素数の生成方法
【2次元配列の宣言と生成】
int[][] a;
a = new array[3][];		//要素数のみの指定でコンパイル可能。

int[][] b = new array[3][3];	//1次元配列と同様に、宣言と生成を同時に行うことが出来る。

int[][] c = new array[][3];		//コンパイルエラー。この記述は要素数を指定せず、1次元配列内の要素数のみを指定している為。

・因みに、2次元配列の他に3次元4次元(何次元でもメモリ領域がある限り)配列も生成可能である。
宣言の際に付けた角括弧([])の数だけ次元が追加される。
2次元以上の配列をまとめて「多次元配列」と呼ぶ。

▼2次元配列の要素への値の代入と参照
・2次元配列への代入は、指定するインデックスが2つになっている。
【2次元配列の要素に値を代入】
int[][] array = new int[3][3];
array[0][0] = 1;
array[0][1] = 2;
array[0][2] = 3;
array[1][0] = 4;
array[2][1] = 5;
array[2][2] = 6;

System.out.println(array[2][1]); //5が出力される。

・上記の代入方法を応用し、宣言された1次元配列を値として代入する事が可能。
【1次元配列を値として要素内に代入】
int[] japanese = {66, 87, 89, 76, 90};
int[] math = {88, 54, 45, 79, 88};
int[] history = {70, 67, 54, 64, 65};

int[][] subjects = new int[3][];
subjects[0] = japanese;
subjects[1] = math;
subjects[2] = history;	//宣言された1次元配列を要素内に追加

System.out.println(subjects[1][2]);		//1次元配列「math」内の2番目のインデックス(3番目の要素)である「45」が出力される。

・2次元配列も宣言と要素への代入を同時に行う事が可能。
配列型名[][] 配列変数名 = {{値1, 値2, 値3...},{値4, 値5, 値6, 値7},.....};
【2次元配列の宣言と値の代入を同時に行うサンプル】
int[][] arrays = {{1, 2, 3},	//波括弧({})1つ分を1つの配列として考える。この行は1つ目の配列(0番目のインデックス)
			{4, 5, 6, 7},		//この行は2つ目の配列(1番目のインデックス)
			{8, 9}};			//この行は3つ目の配列(2番目のインデックス) 1次元配列では値を波括弧({})で囲って記述出来たが、それをさらに上から波括弧で囲う形で記述可能。
System.out.println(arrays[1][3]);	//1番目のインデックスの配列の3番目のインデックスの要素「7」が出力される。

int[][] array = new int[][]{};	//コンパイル可能。インデックスが0の配列インスタンスが生成される。
int[][] array = {};				//コンパイル可能。こちらは同上の意を持つ。
int[][] array = new int[]{};	//コンパイルエラー。配列インスタンスの次元数が一致していない為。

▼2次元配列での要素数(length)
・2次元配列は大きく分け、2種類の要素数を保持している。
1,2次元配列自体の要素数(格納する配列の数)
2,格納する配列内の要素数

1の取得方法は以下のように行う。
配列変数名.length;
2の取得方法は以下のように行う。
配列変数名[インデックス].length;

・以下がそれぞれを参照するサンプル
【2次元配列の要素数(length)】
int[][] arrays = {{1, 2, 3},
			{4, 5, 6, 7},
			{8, 9}};  //3つの1次元配列を格納する2次元配列を初期化
System.out.println("配列の要素数 : " + arrays.length + "  1次元配列内の要素数 : " + arrays[1].length); //それぞれ「3」,「4」と出力される。
▼シャローコピー・ディープコピー
・配列は参照型なので、他の参照型と同様に同一と同値の概念が適用される。
同一の状態は、他の参照型と同様に代入演算子(=)で同じ参照を持たせる事で表現し、
同値の状態は、同じ要素を保持する配列インスタンスを生成するか、「[配列変数名].clone」メソッドを呼び出す事で表現可能。

▼コレクション
・IndexOutOfBoundsExceoptionクラスはArrayIndexOutOfBoundsExceptionクラスとStringIndexOutOfExceptionクラスの親クラス。
・ArrayIndexOutOfBoundsExceptionは配列の要素外にアクセスした際に発生。
・StringIndexOutOfBoundsExceptionは文字列の範囲外にアクセスした際に発生。
・IndexOutOfExceptionはコレクションインターフェースを実装したクラスのコレクション範囲外にアクセスした際に発生。


■継承について
▼ 継承されないもの
・コンストラクタとprivateメンバは継承されないので注意。

▼ 抽象クラス(メソッド)
・インスタンスメソッドかクラスに付与出来る。
・abstract修飾子が付与されたクラスはインスタンス化できない。
・abstract修飾子を付与するメソッドは必ずabstractクラスに定義する。
・abstractクラスを継承するクラスは必ずabstractメソッドをオーバーライドしなくてはならない。
・抽象クラスを継承した抽象クラスを定義することは可能。(その抽象クラスの具象クラスが全ての抽象メソッドをオーバーライドしなくてはならない。)
・インターフェースの継承はできない。
・インターフェースを実装することは可能。しかし、インターフェース内の抽象メソッドをオーバーライドしなくてもよい。(その抽象クラスの具象クラスが全ての抽象メソッドをオーバーライドしなくてはならない。)

▼ インターフェース
・インターフェースのインスタンスを生成することはできない。
・staticメソッドは処理を持たせて、定義可能。(staticな抽象メソッドがそもそも定義できない。)
・インターフェースで宣言するメソッドは暗黙的に「puclic abstract」な抽象メソッドとなる。(なので省略し、戻り値の記述とメソッド名を書くだけでOK)
・インターフェースで宣言したフィールドは、暗黙的に「public static final」な定数となる。(なので省略し、型名と変数名を書くだけでOK)
・インターフェースは暗黙的に「public abstract」となる。(なので「interface」キーワード+インターフェース名のみでOK)
・インターフェースを多重実装する際の記述は「implements」キーワードにカンマ区切りでインターフェース名を記述していく。「implements」キーワードを複数書くわけではないので注意。
・インターフェースは継承可能。しかし、クラスの継承を行うことは出来ない。継承出来るのは別のインターフェースのみ。
・インターフェースは多重継承可能。クラスと異なり、複数のインターフェースを継承出来る。
・インターフェースには原則として実装を持つメソッドは定義できない。ただしJava8からは「defaultメソッド」が追加され、修飾子に「default」を記述すれば定義可能。そのメソッドインターフェースを実装すればオーバーライドせずに呼び出す事が可能。
・インターフェースの抽象メソッドを実装するのは必ずしも実装クラスである必要はない。実装クラスが親クラスを持つ場合、親クラス内でインターフェース内抽象メソッドのオーバーライドを成立させるメソッドが定義されていれば実装されているとみなされる。
・抽象クラスを１つのみ定義しているインターフェースを関数型インターフェースと呼ぶ。

■匿名クラス(インナークラス)
▼関数型インターフェースの実装
・インターフェースに定義されたメソッドを使用するには、基本的に以下のステップが必要となる。
1,インターフェースの定義
2,インターフェースの実装
3,実装クラスのインスタンスを生成〜実行

・インターフェースを関数として利用する際、上記のステップを行うと関数型インターフェースのメソッドを実装するためだけに１つのクラスファイルを作らなければならない。
・上記のような冗長したコードを緩和するため、Javaは匿名クラスを実装している。
・匿名クラスはクラス内に名前を持たないもう一つのクラスを作成する。
以下のように作成出来る。。
【匿名クラスサンプル】
public interface Flyable{   //一度のみ実装したい「Flyable」インターフェース
    void fly();
}

public class Main(){    //「Flyable」インターフェースの「fly」メソッドを実装、実行を同時に行うクラス。「implements」キーワードによる実装を必要としない。
    public static void main (String []args){
        Flyable bird = new Flyable(){ //匿名クラスを生成する際の記法
            @Override   //ここからが匿名クラスの内部
            public void fly(){  //flyメソッドを実装
                System.out.println("flying...");
            }        
        };  //匿名クラスはブロックの最後に「;」を記述。
        bird.fly(); //実装したメソッドを実行。「flying...」が出力される。
    }
}

▼ フィールド
・サブクラス内で、スーパクラスに定義されているフィールドと同名のフィールドを定義することが可能。
そのため、サブクラス内では、同名の２つのメソッドが存在している状態となる。
どちらのフィールドを参照するかのルールが２つ存在する。
(1)フィールドを参照した場合、変数の型で宣言された方を使用。
(2)メソッドを呼び出した際は、メソッド内の支持に従う。

(1)は、ポリモーフィズムを利用しフィールドにアクセスした際、どちらのフィールドにアクセスするかは、宣言した変数の型内で定義された値にアクセスする。
(2)は、スーパークラス内で定義されたメソッドをサブクラス内でオーバーライドしていた場合、そのメソッド内で定義された値にアクセスされる。

▼ ポリモーフィズム
・ポリモーフィズムは実際に動作しているインスタンスを、インスタンスの元となった型とは「異なる型」で扱える仕組み。ただし、互換性のない型に変換はできない。
ポリモーフィズムを成立させるには、「継承の関係」または、「実装の関係」が必要となる。
・利用する際、宣言の際に扱っている型に定義されていないメソッドは使用出来ない。
クラスAに「methodA」が定義されており、クラスAを継承するクラスBに「methodB」が定義されているとする。
クラスBはmethodAとmethodBの両方を持っているが、ポリモーフィズムを利用し、 A obj = new B();　とし、objをA型で扱っている場合、objから、「methodB」にアクセス出来ないので注意。

■例外について
▼ 主要例外クラス
・IllegalStateException  ...引数に渡されたパラメータの状態が不正の場合スロー(仕様上の例外)

▼ tryブロック
・tryブロックはtry-catch-finallyの中に複数記述出来ない。(ネストは出来る)

▼ catchブロック
・catchブロックは複数記述可能。
・catchブロックは省略可能。その際はthrows句で例外を定義し、try{}finally{}の形とする。finallyブロックに例外発生時に必ず実行したい処理を記述する。
・catchブロックに定義する例外クラスも他のクラスと同様にポリモーフィズムが適用される。
なので複数のcatchブロックが存在する時、上に定義された例外クラスが下に定義された例外クラスのスーパークラスであった場合、ポリモーフィズムが適用され、サブクラスの例外が発生したとしても全てスーパークラスの例外としてキャッチしてしまう。
下で定義されているサブクラスのcatchブロックはデッドコードとなりコンパイルエラーとなるため、上にすでに定義されたスーパークラスを継承しているサブクラスのcatchブロックは記述できない。(逆であればOK)
・ネストされたtry-catchブロックで例外が発生した場合、発生した例外に最も近いブロックのcatchブロックの処理が適用される。その際にfinallyブロックが外側にも内側にも存在していた場合、両方実行されるので注意。

▼ finallyブロック
・finallyブロックはcatchブロック以降にのみ記述可能。(try-catch-finallyの順番を入れ替えることは出来ない。)
・finallyブロックはtry-catch-finallyの中に複数記述出来ない。
・finallyブロックは例外発生の有無に関わらず必ず実行される。
finallyブロックが定義されたメソッドを呼び出した際、finallyブロック以前に戻り値をreturnしていたとしても、必ずメソッドの最後に実行される。
finallyブロックが実行されないのはtryブロック、catchブロック内で「System.exit」メソッドによりアプリケーションを強制終了した時か、JVMかOSがクラッシュした時のみ。(クラス内で記述されていれば必ず実行される。)
・finallyブロックでメソッドの戻り値を再代入したり演算しても、参照を持たない基本型であれば返却値は変わらない。

▼ スロー
・複数の例外を「throws」する時の構文は、「throws A,B」のようにコンマ区切りで記述。throws句は複数記述不要。

▼ Throwable
・ErrorクラスもExceptionクラスもThrowableクラスの子クラス。RuntimeExceptionクラスはExceptionクラスの子クラス。
・Exceptionクラスの例外は検査例外と呼ばれ、発生する可能性のある箇所でスローするかtry-catch文を記述するかの対応が必須となる。RuntimeExceptionクラスの例外は非検査例外と呼ばれ対応は必須ではない。(なにも対応しなくてもコンパイルエラーが発生しない。)
・エラーはErrorクラスを継承していなければならない。
・エラーはプログラムの実行環境に例外が発生している時にスローされる。メモリが不足していたり、読み込みや書き込みへの権限がなかったり、ネットワーク接続が出来ていないなど、実行環境上のトラブルであるため、プログラムからの対処はしようがない例外。
・エラーは例外処理を行う事を「求められていない」だけであり、try-catch文などでキャッチし、例外処理を行う事自体は可能。
・スタック領域が足りなくなると、「StackOverFlowError」となる。
メソッドが呼び出されると、メソッドの実行に必要な情報がメモリのスタック領域に配置される。次々とメソッドを呼び出すと、スタック領域にメソッド情報が積み重なっていく。
スタック領域は有限なので同じメソッドを呼び続ける「再帰呼出し(mainメソッド内でmainメソッド呼び出したり)」を行っていると、スタック領域がなくなることがある。JVMがそのことを検知すると、「StackOverFlowError」をスローし、プログラムを強制終了する。
・クラスファイルを発見出来ないときにスローされる例外が「ClassDefNotFoundError」
・ヒープ領域が足りなくなると、「OutOfMemoryError」となる。
インスタンスを保存したり、クラスの定義情報を保存したりするメモリ上の領域をヒープ領域という。
大量のインスタンスを生成し、ガベージコレクトが行われないとヒープ領域が一杯になり、新しいインスタンスが生成出来なくなってしまう。
この事態をJVMが検知すると、「OutOfMemoryError」を発生させ、プログラムを強制終了させる。
メソッドの実行順を制御するためのスタック領域で発生する「StackOverFlowError」とは混合しやすいので注意。
・JVM内で何らかの内部エラーが発生すると、「InternalError」が発生する。
・「OutOfMemoryError」と「StackOverFlowError」「InternalError」の親クラスに「VirtualMachineError」がある。
JVMが壊れているか、動作を継続するのに必要なりソースが不足しているため発生するエラー。


▼ Initializer
・staticイニシャライザはクラスを利用する時にJVMによって自動的に実行されるメソッドなので、任意で呼び出すことは出来ない。
・staticイニシャライザ内で発生した例外は「ExceptionInInitializerError」を発生させ、プログラムを強制終了させる。


■Java APIについて
▼ Stringクラス
・Stringクラスのインスタンスを生成する代表的な方法は、newする方法と、""(ダブルクオーテーション)で文字列を代入する方法の2つ。
前者はメモリ領域に新しい参照を生成しているのに対し、後者はコンスタントプールの機能によって、文字列用インスタンス領域に格納される。
文字列用インスタンス領域に格納されたインスタンスは、同じ文字列を保持する他のStringオブジェクトと同じ参照を持つため、「同一」のインスタンスとなる。
また、Stringクラスのstaticメソッドである、「valueOf」メソッドでもインスタンスを生成することが可能。(toStringはインスタンスメソッドであるため、呼び出しにインスタンスが必要。)
・「valueOf」メソッドは、引数パラメータを文字列に変換するstaticメソッドだが、
「toString」メソッドは、「Objectクラス」に定義された、全てのクラスが保持するインスタンスメソッド。引数ではなく、呼び出したインスタンス変数の値を文字列に変換する。
挙動の違いとして、「null」がパラメータとして渡された時、「valueOf」メソッドは内部で「null」を文字列に変換するのに対し、「toString」は「null」のまま返却する。 
・Stringオブジェクトは不変(immutable)オブジェクトである。逆に可変は(mutable)
不変オブジェクトとは、値が「final」で保持されており、再代入することが出来ない。
・Stringクラスは「final」修飾子により継承されることを禁止している。
また、文字列として保持するデータは「private final」で定義されており、新しい文字列を生成したい場合は、新しいインスタンスを生成しなくてはならない。
・Stringクラスのメソッドの「replaceAll」メソッドは上記の理由により、新しいStringクラスのインスタンスを生成し、置換した文字列を返却する。元の文字列の参照は変わらないため、他のStringオブジェクトに代入して利用する必要がある。
・Stringクラスのオブジェクトは、内部でchar型の配列となっているため、「charAt」メソッドなどで、文字列の位置を指定する場合は配列の要素数を指定する時と同様に「0」から始まる。
・CharSequence型はCharクラスとStringクラスの親クラス。

○Stringクラスのメソッド
・valueOf(String str)(staticメソッド)    　 ...渡された引数パラメータの値を文字列に変換するstaticメソッド。
・replace(String str1, String str2)       ...引数「str1」に置換される文字列をセットし、「str2」に置換する文字列をセットする。「"AAABAAAB"」という文字列に対し、引数に("AAA","C")で呼び出すと、結果は「"CBCB"」となる。
・replaceAll(String str1, String str2)    ...上記のreplaceと同様の挙動をするが、置換される文字列を正規表現でも指定できる。
・replaceFirst(String str1, String str2)  ...上記のreplaceAll同様に正規表現で置換される文字列を指定し、正規表現に一致する文字列を右から一箇所だけ置換する。
・charAt(int index)                       ...インスタンスが保持している文字列から、引数パラメータで渡された位置の1文字だけを抜き出してchar型の文字で返却する。(文字列範囲外を指定すると「StringIndexOutOfOBoundsException」となる。
・indexOf(charSec c)                      ...引数で指定された文字が文字列の何番目の位置に存在するかを調べるメソッド。
このメソッドはオーバーロードされており、char型で引数を渡すとその文字のある要素番号を、String型で引数を渡すとその文字列と一致する位置の先頭の要素番号を返却する。引数に文字列内に存在しない文字を渡すと「-1」が返却される。
・subString(int index1, int index2)       ...文字列内から任意の文字列のみ抜き出す際に使用するメソッド。「index1」に要素数の開始番号を渡し、「index2」に要素数の終了番号を渡すことでその要素番号の範囲内の文字列を返却する。
注意すべきは終了番号で、終了番号に指定する要素番号は5文字であれば「5」まで指定することが出来る事。開始indexは「0」から始まるが文字列を抜き取るというより、文字列から指定した範囲を抜き取るイメージのほうが近い。
このメソッドはオーバーロードされており、開始indexのみを指定して呼び出す事も可能。その際開始index以降の文字列が返却される。
また、文字列範囲外を指定すると、「StringIndexOutOfOBoundsException」となる。
・trim                                    ...文字列の前後に存在する空白を除去するためのメソッド。前後の空白のみなので、文字列内の空白は除去されない。3つエスケープシーケンスを覚えておく。→ /t(タブ文字)  /n または　/r(改行) 
・length                                  ...文字数を返却する。全角も半角も「1」文字としてカウントされるので注意。
・startWith(String str)                   ...Stringオブジェクトが保持する値が引数パラメータに渡された文字列で始まっていたら「true」を返却。
・endWith(String str)                     ...Stringオブジェクトが保持する値が引数パラメータに渡された文字列で終わっていたら「true」を返却。
・split(String str)                       ...引数「str」を正規表現で指定し、

▼ StringBuilderクラス
・Stringクラスは不変(immutable)であるため、文字列を連結したり挿入する際に可変クラスであるStringBuilerを利用する。
String str = "abc" + "def" "ghi";
上記の例では、合計で3つのString型インスタンスを生成している事となる。

○append(String str)
・StringBuilderクラスのメソッド
・文字列を連結させる際に使用する。
上記のStringクラスでの文字列の連結を、「append」メソッドで行うと以下のようになる。
【appendメソッドのサンプル】
StringBuilder sb = new StringBuilder("abc");   //コンストラクタに"abc"を初期値として渡す。
sb.append("def"); //文字列"def"を連結
sb.append("ghi"); //文字列"ghi"を連結
System.out.println(sb.toString()); //「toString」メソッドでString型の文字列へ変換する。結果は:"abcdehghi"となる。

・引数として「null」を渡した場合、「"null"」の4文字が連結される。
・String型の文字列だけではなく、基本型やラッパークラスのすべてを引数として渡し、文字列へ変換する事が可能。

○insert(int offset, String str)
・「append」メソッドは文字列の末尾から文字列を連結させるが、「insert」メソッドは文字列の指定した位置に文字列を挿入する。
・引数である「offset」に位置を渡す。先頭から文字列を挿入する場合、渡す引数は「0」となる。
【insertメソッドのサンプル】
StringBuilder sb = new StringBuilder("Hello World!"); //コンストラクタに"Hello World!"を初期値として渡す。
sb.insert(6,"My"); //6番目の位置に文字列"My"を挿入。
System.out.println(sb.toString()); //"Hello MyWorld!"が出力される。 

▼ ラムダ式
・ラムダ式は匿名クラスを生成せず、関数型インターフェースの実装をよりシンプルに記述できるようにした式。
・下記がサンプル
【ラムダ式のサンプル】
public interface Flyable{   //一度のみ実装したい「Flyable」インターフェース
    void fly(String name);
}

public class Main{    //ラムダ式を利用して関数型インターフェースを実装するクラス
    public static void main(String[] args){
        Flyable bird = name -> System.out.println(name + " is flying....");　//ラムダ式で「Flyable」を実装
        bird.fly("piyo"); //「piyo is flying...」が出力される。
    }
}
・上記のように、匿名クラスを使用した際と比べ、コーディングの量が少なくなる。
・また、匿名クラスのようにクラスファイルが生成されないため、メモリの節約にもなっている。
・記述の際にいくつかのルールが存在する。
・引数の型は推測されるため省略可能。(書いてもよい)
・引数が2つ以上の場合、(name, age) -> のように、括弧で引数を囲う。
・引数がないとき、() -> のように括弧のみを記述(記述しないとコンパイルエラー)
・アロー(->)の右辺側に記述する処理が2行以上の場合、ブロック({})で処理を記述しなければならない。
・処理が1行の場合、戻り値を返すメソッドでもreturnキーワードは省略可能。

▼ ArrayListクラス
・Collectionインターフェースを実装したクラス。
・可変長(mutable)の配列を使用する際に利用するクラス。
配列は要素数を指定後、要素数を追加したり、要素数以上の要素を代入出来ないが、ArrayListは要素数以上の要素が代入された際に自動的に要素数が追加されていく(そのため、要素数を指定する必要がない。)
・ArrayListは、ArrayList list = new ArrayList(5); //コンストラクタにキャパシティを渡しているが、自動で追加されるため、省略してもコンパイルエラーとならない。
上記のように宣言できる。上記のように宣言した場合、要素の型は「Object」型となり、全ての値を代入することが出来る。
しかし、１つの型(データ)のまとまりであるという保証がない配列を利用するのは予期せぬエラーを引き起こす原因となるため、「ジェネリクス」を利用し、型を限定する事が推奨される。
・ジェネリクスを利用した宣言方法は、ArrayList<Integer> list = new ArrayList<Integer>(); //<>の部分が「ジェネリクス」型の宣言とインスタンス生成両方に記述出来るが、インスタンス生成側のジェネリクスは省略可能。(書いた方がよい)
・ジェネリクスに型を指定することにより、要素に代入出来る型はジェネリクスに指定した型のみである保証になる。仮に上記の宣言方法をしたArrayListにString型の文字列を代入するとコンパイルエラーとなる。
・ジェネリクスにプリミティブ型を指定することは出来ない。指定する際は必ずラッパークラスを利用する。
・配列と異なり、要素すべてを参照する場合は、System.out.println(リスト変数名);で参照可能。

○add(<T> data)_追加
引数に値を渡し、リストの要素に追加する。
又は、add(index,<T>data)
引数に要素番号と値を渡し、指定した要素番号に値を追加する。

○get(int index)_参照
引数に要素番号を渡し、指定した要素番号の要素を取り出す。

○set(int index, <T>data)_上書き
引数に要素番号と値を渡し、指定した要素番号の要素を渡した値で上書く。

○remove(int index)_削除
引数に要素番号を渡し、指定した要素番号の要素を削除する。

○addAll(List<T> obj)
引数にList型の変数を渡し、変数内の要素を末尾から全て追加する。
※ArrayListをList型で宣言している必要がある。

○removeAll(List<T> obj)
引数にList型の変数を渡し、変数内の要素内の値と同値の要素を全て削除する。
※ArrayListをList型で宣言している必要がある。

○size()_要素数
Listの要素数を数値で返却する。
※lengthでないので注意。

○clear()_全削除
Listの要素を全て削除する。

○contains(Object e)_要素を含むか判定する
引数に値を渡し、List内に同値の要素が存在するか判定する。

○indexOf(Object e)_要素番号取得
引数に値を渡し、List内の同値要素の先頭要素番号を返却する。

○forEach(lambda expression)
引数にラムダ式を記述し、List内の要素に順番にアクセスする。
List<String> list = Arrays.asList("A","B","C");
list.forEach(a -> System.out.println(a));

▼ Predicateインターフェース

▼ Durationクラス
・TemporalAmountインターフェースを実装
・Durationは時間ベースの時間量(3時間40分など)を表す。
○ofDays(long days) [static]
Durationインスタンスを24時間の日付単位で、生成する際に用いる。
Duration duration = Duration.ofDays(12);
上記の例だと、12日間の期間を保持したインスタンスを生成している。

○

▼ LocalDateクラス

▼ Periodクラス
・TemporalAmountインターフェースを実装

▼ DateTimeFormatterクラス

